1. 解析後的問題:將陣列中數值增加後(增加總額<=k)，最常出現數字的數量。
2. 可能的方法:排序後使離k最近的數字作為target，選定target後由小於且離target最近的數字開始作為num，
    使k減去target-num，若k>=0則ans++，若<0則return ans。
3. 失敗，頻率最高的數字不一定是離k最近的數字。
4. 問題分析:n個陣列中<=target的值與target的距離加起來<=k，n的最大值為何?
5. 可能的方法:排序後使index由0開始並使<=index位置的數字持續增加直到與當前index數字相同，全部運算後若k>=0則index換到下一個並記錄當前ans是否最大，
    若k<0則使最小的數字還原、k+=(index的數字 - 最小的數字)。
6. 成功，時間複雜度O(nlogn)，因為有排序。
7. 概念:排序後利用L~R的固定性，使得(R-L)*(nums[R] - nums[R-1])為當前k所要負擔的值，若無法負擔則使L++，負擔值變小，若尚可負擔則R++，
    負擔持續增加，並在此過程中記錄R-L+1是否>ans，若是則ans更新為R-L+1。